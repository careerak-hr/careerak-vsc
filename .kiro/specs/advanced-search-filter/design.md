# ŸÜÿ∏ÿßŸÖ ÿßŸÑŸÅŸÑÿ™ÿ±ÿ© ŸàÿßŸÑÿ®ÿ≠ÿ´ ÿßŸÑŸÖÿ™ŸÇÿØŸÖ - ÿßŸÑÿ™ÿµŸÖŸäŸÖ ÿßŸÑÿ™ŸÇŸÜŸä

## üìã ŸÖÿπŸÑŸàŸÖÿßÿ™ ÿßŸÑŸàÿ´ŸäŸÇÿ©

- **ÿßÿ≥ŸÖ ÿßŸÑŸÖŸäÿ≤ÿ©**: ŸÜÿ∏ÿßŸÖ ÿßŸÑŸÅŸÑÿ™ÿ±ÿ© ŸàÿßŸÑÿ®ÿ≠ÿ´ ÿßŸÑŸÖÿ™ŸÇÿØŸÖ
- **ÿ™ÿßÿ±ŸäÿÆ ÿßŸÑÿ•ŸÜÿ¥ÿßÿ°**: 2026-02-17
- **ÿßŸÑÿ≠ÿßŸÑÿ©**: ŸÇŸäÿØ ÿßŸÑÿ™ÿµŸÖŸäŸÖ
- **ÿßŸÑŸÖÿ∑Ÿàÿ±**: Eng.AlaaUddien

---

## 1. Overview

ŸÜÿ∏ÿßŸÖ ÿßŸÑŸÅŸÑÿ™ÿ±ÿ© ŸàÿßŸÑÿ®ÿ≠ÿ´ ÿßŸÑŸÖÿ™ŸÇÿØŸÖ ŸáŸà ŸÜÿ∏ÿßŸÖ ÿ¥ÿßŸÖŸÑ ŸäŸàŸÅÿ± ŸÑŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖŸäŸÜ ÿßŸÑŸÇÿØÿ±ÿ© ÿπŸÑŸâ ÿßŸÑÿ®ÿ≠ÿ´ ÿπŸÜ ÿßŸÑŸàÿ∏ÿßÿ¶ŸÅ ŸàÿßŸÑÿØŸàÿ±ÿßÿ™ ÿßŸÑÿ™ÿØÿ±Ÿäÿ®Ÿäÿ© ÿ®ÿ∑ÿ±ŸäŸÇÿ© ÿ∞ŸÉŸäÿ© ŸàŸÅÿπÿßŸÑÿ©. Ÿäÿ™ÿ∂ŸÖŸÜ ÿßŸÑŸÜÿ∏ÿßŸÖ:

- **ŸÖÿ≠ÿ±ŸÉ ÿ®ÿ≠ÿ´ ŸÜÿµŸä ÿ∞ŸÉŸä** ŸäÿØÿπŸÖ ÿßŸÑÿ®ÿ≠ÿ´ ŸÅŸä ÿ≠ŸÇŸàŸÑ ŸÖÿ™ÿπÿØÿØÿ© ŸÖÿπ ÿßŸÇÿ™ÿ±ÿßÿ≠ÿßÿ™ ÿ™ŸÑŸÇÿßÿ¶Ÿäÿ©
- **ŸÜÿ∏ÿßŸÖ ŸÅŸÑÿ™ÿ±ÿ© ŸÖÿ™ŸÇÿØŸÖ** ŸÖÿπ ÿØÿπŸÖ ŸÅŸÑÿßÿ™ÿ± ŸÖÿ™ÿπÿØÿØÿ© ŸàŸÖŸÜÿ∑ŸÇ AND/OR ŸÑŸÑŸÖŸáÿßÿ±ÿßÿ™
- **ÿ≠ŸÅÿ∏ ÿπŸÖŸÑŸäÿßÿ™ ÿßŸÑÿ®ÿ≠ÿ´** ŸÖÿπ ÿ•ŸÖŸÉÿßŸÜŸäÿ© ÿ•ÿπÿßÿØÿ© ÿßÿ≥ÿ™ÿÆÿØÿßŸÖŸáÿß ÿ®ŸÜŸÇÿ±ÿ© Ÿàÿßÿ≠ÿØÿ©
- **ÿ™ŸÜÿ®ŸäŸáÿßÿ™ ÿ∞ŸÉŸäÿ©** ÿ™Ÿèÿ±ÿ≥ŸÑ ÿ™ŸÑŸÇÿßÿ¶ŸäÿßŸã ÿπŸÜÿØ ÿ∏ŸáŸàÿ± ŸÜÿ™ÿßÿ¶ÿ¨ ÿ¨ÿØŸäÿØÿ©
- **ÿπÿ±ÿ∂ ÿÆÿ±Ÿäÿ∑ÿ© ÿ™ŸÅÿßÿπŸÑŸä** ŸÑÿπÿ±ÿ∂ ÿßŸÑŸàÿ∏ÿßÿ¶ŸÅ ÿ¨ÿ∫ÿ±ÿßŸÅŸäÿßŸã
- **ŸÜÿ∏ÿßŸÖ ŸÖÿ∑ÿßÿ®ŸÇÿ© ÿßŸÑŸÖŸáÿßÿ±ÿßÿ™** ŸÖÿπ ÿ≠ÿ≥ÿßÿ® ŸÜÿ≥ÿ®ÿ© ÿßŸÑÿ™ÿ∑ÿßÿ®ŸÇ

### ÿßŸÑÿ£ŸáÿØÿßŸÅ ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿäÿ©

1. **ÿßŸÑÿ≥ÿ±ÿπÿ©**: ŸÜÿ™ÿßÿ¶ÿ¨ ÿ®ÿ≠ÿ´ ÿÆŸÑÿßŸÑ ÿ£ŸÇŸÑ ŸÖŸÜ 500ms
2. **ÿßŸÑÿØŸÇÿ©**: ŸÜÿ™ÿßÿ¶ÿ¨ ŸÖÿ∑ÿßÿ®ŸÇÿ© ÿ®ÿØŸÇÿ© ÿπÿßŸÑŸäÿ© ŸÑŸÖÿπÿßŸäŸäÿ± ÿßŸÑÿ®ÿ≠ÿ´
3. **ÿ≥ŸáŸàŸÑÿ© ÿßŸÑÿßÿ≥ÿ™ÿÆÿØÿßŸÖ**: Ÿàÿßÿ¨Ÿáÿ© ÿ®ÿØŸäŸáŸäÿ© ŸÖÿπ ÿ™ÿ¨ÿ±ÿ®ÿ© ŸÖÿ≥ÿ™ÿÆÿØŸÖ ÿ≥ŸÑÿ≥ÿ©
4. **ÿßŸÑÿ∞ŸÉÿßÿ°**: ÿßŸÇÿ™ÿ±ÿßÿ≠ÿßÿ™ ÿ∞ŸÉŸäÿ© ŸàŸÖÿ∑ÿßÿ®ŸÇÿ© ŸÖÿ™ŸÇÿØŸÖÿ© ŸÑŸÑŸÖŸáÿßÿ±ÿßÿ™

---

## 2. Architecture

### 2.1 ÿßŸÑŸÖÿπŸÖÿßÿ±Ÿäÿ© ÿßŸÑÿπÿßŸÖÿ©

ÿßŸÑŸÜÿ∏ÿßŸÖ Ÿäÿ™ÿ®ÿπ ŸÖÿπŸÖÿßÿ±Ÿäÿ© ÿ´ŸÑÿßÿ´Ÿäÿ© ÿßŸÑÿ∑ÿ®ŸÇÿßÿ™ (Three-Tier Architecture):

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    Presentation Layer                    ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇ Search Page  ‚îÇ  ‚îÇ  Map View    ‚îÇ  ‚îÇ Saved Panel  ‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                            ‚îÇ
                            ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    Business Logic Layer                  ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇSearchService ‚îÇ  ‚îÇ FilterService‚îÇ  ‚îÇ AlertService ‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                            ‚îÇ
                            ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                      Data Layer                          ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇ   MongoDB    ‚îÇ  ‚îÇ  Text Index  ‚îÇ  ‚îÇ  Geo Index   ‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### 2.2 ŸÖŸÉŸàŸÜÿßÿ™ ÿßŸÑŸÜÿ∏ÿßŸÖ

#### Backend Components

1. **SearchController**: ŸÖÿπÿßŸÑÿ¨ ÿ∑ŸÑÿ®ÿßÿ™ ÿßŸÑÿ®ÿ≠ÿ´ ŸàÿßŸÑŸÅŸÑÿ™ÿ±ÿ©
2. **SearchService**: ŸÖŸÜÿ∑ŸÇ ÿßŸÑÿ®ÿ≠ÿ´ ŸàÿßŸÑŸÖÿ∑ÿßÿ®ŸÇÿ©
3. **FilterService**: ÿ™ÿ∑ÿ®ŸäŸÇ ÿßŸÑŸÅŸÑÿßÿ™ÿ± ÿßŸÑŸÖÿ™ÿπÿØÿØÿ©
4. **SavedSearchService**: ÿ•ÿØÿßÿ±ÿ© ÿπŸÖŸÑŸäÿßÿ™ ÿßŸÑÿ®ÿ≠ÿ´ ÿßŸÑŸÖÿ≠ŸÅŸàÿ∏ÿ©
5. **AlertService**: ÿ•ÿØÿßÿ±ÿ© ÿßŸÑÿ™ŸÜÿ®ŸäŸáÿßÿ™ ÿßŸÑÿ∞ŸÉŸäÿ©
6. **MatchingEngine**: ÿ≠ÿ≥ÿßÿ® ŸÜÿ≥ÿ®ÿ© ŸÖÿ∑ÿßÿ®ŸÇÿ© ÿßŸÑŸÖŸáÿßÿ±ÿßÿ™

#### Frontend Components

1. **SearchBar**: ÿ¥ÿ±Ÿäÿ∑ ÿßŸÑÿ®ÿ≠ÿ´ ŸÖÿπ autocomplete
2. **FilterPanel**: ŸÑŸàÿ≠ÿ© ÿßŸÑŸÅŸÑÿßÿ™ÿ± ÿßŸÑÿ¨ÿßŸÜÿ®Ÿäÿ©
3. **ResultsList**: ÿπÿ±ÿ∂ ÿßŸÑŸÜÿ™ÿßÿ¶ÿ¨
4. **MapView**: ÿπÿ±ÿ∂ ÿßŸÑÿÆÿ±Ÿäÿ∑ÿ© ÿßŸÑÿ™ŸÅÿßÿπŸÑŸäÿ©
5. **SavedSearchesPanel**: ŸÑŸàÿ≠ÿ© ÿπŸÖŸÑŸäÿßÿ™ ÿßŸÑÿ®ÿ≠ÿ´ ÿßŸÑŸÖÿ≠ŸÅŸàÿ∏ÿ©
6. **AlertsManager**: ÿ•ÿØÿßÿ±ÿ© ÿßŸÑÿ™ŸÜÿ®ŸäŸáÿßÿ™

### 2.3 ÿ™ÿØŸÅŸÇ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™

```
User Input ‚Üí SearchBar ‚Üí SearchController ‚Üí SearchService
                                                  ‚îÇ
                                                  ‚îú‚Üí FilterService
                                                  ‚îú‚Üí MatchingEngine
                                                  ‚îî‚Üí Database Query
                                                          ‚îÇ
                                                          ‚ñº
                                                    Results
                                                          ‚îÇ
                                                          ‚îú‚Üí ResultsList
                                                          ‚îî‚Üí MapView
```

---

## 3. Components and Interfaces

### 3.1 Backend APIs

#### Search API

```javascript
// GET /api/search/jobs
// Query Parameters:
{
  q: string,              // ŸÉŸÑŸÖÿ© ÿßŸÑÿ®ÿ≠ÿ´
  location: string,       // ÿßŸÑŸÖŸàŸÇÿπ
  salaryMin: number,      // ÿßŸÑÿ≠ÿØ ÿßŸÑÿ£ÿØŸÜŸâ ŸÑŸÑÿ±ÿßÿ™ÿ®
  salaryMax: number,      // ÿßŸÑÿ≠ÿØ ÿßŸÑÿ£ŸÇÿµŸâ ŸÑŸÑÿ±ÿßÿ™ÿ®
  workType: string[],     // ŸÜŸàÿπ ÿßŸÑÿπŸÖŸÑ
  experienceLevel: string[], // ŸÖÿ≥ÿ™ŸàŸâ ÿßŸÑÿÆÿ®ÿ±ÿ©
  skills: string[],       // ÿßŸÑŸÖŸáÿßÿ±ÿßÿ™
  skillsLogic: 'AND' | 'OR', // ŸÖŸÜÿ∑ŸÇ ÿßŸÑŸÖŸáÿßÿ±ÿßÿ™
  datePosted: string,     // ÿ™ÿßÿ±ŸäÿÆ ÿßŸÑŸÜÿ¥ÿ±
  companySize: string[],  // ÿ≠ÿ¨ŸÖ ÿßŸÑÿ¥ÿ±ŸÉÿ©
  page: number,           // ÿ±ŸÇŸÖ ÿßŸÑÿµŸÅÿ≠ÿ©
  limit: number,          // ÿπÿØÿØ ÿßŸÑŸÜÿ™ÿßÿ¶ÿ¨
  sort: string            // ÿßŸÑÿ™ÿ±ÿ™Ÿäÿ®
}

// Response:
{
  success: true,
  data: {
    results: JobPosting[],
    total: number,
    page: number,
    pages: number,
    filters: {
      applied: FilterObject,
      available: AvailableFilters
    }
  }
}
```

#### Autocomplete API

```javascript
// GET /api/search/autocomplete
// Query Parameters:
{
  q: string,              // ÿßŸÑŸÜÿµ ÿßŸÑŸÖÿØÿÆŸÑ
  type: 'jobs' | 'courses', // ŸÜŸàÿπ ÿßŸÑÿ®ÿ≠ÿ´
  limit: number           // ÿπÿØÿØ ÿßŸÑÿßŸÇÿ™ÿ±ÿßÿ≠ÿßÿ™
}

// Response:
{
  success: true,
  data: {
    suggestions: string[]
  }
}
```

#### Saved Searches API

```javascript
// POST /api/search/saved
// Body:
{
  name: string,           // ÿßÿ≥ŸÖ ÿπŸÖŸÑŸäÿ© ÿßŸÑÿ®ÿ≠ÿ´
  searchParams: SearchParams, // ŸÖÿπÿßŸÖŸÑÿßÿ™ ÿßŸÑÿ®ÿ≠ÿ´
  alertEnabled: boolean,  // ÿ™ŸÅÿπŸäŸÑ ÿßŸÑÿ™ŸÜÿ®ŸäŸáÿßÿ™
  alertFrequency: 'instant' | 'daily' | 'weekly'
}

// GET /api/search/saved
// Response:
{
  success: true,
  data: {
    savedSearches: SavedSearch[]
  }
}

// PUT /api/search/saved/:id
// DELETE /api/search/saved/:id
```

#### Alerts API

```javascript
// POST /api/search/alerts
// Body:
{
  savedSearchId: ObjectId,
  frequency: 'instant' | 'daily' | 'weekly',
  notificationMethod: 'push' | 'email' | 'both'
}

// GET /api/search/alerts
// PUT /api/search/alerts/:id
// DELETE /api/search/alerts/:id
```

#### Map Search API

```javascript
// GET /api/search/map
// Query Parameters:
{
  bounds: {
    north: number,
    south: number,
    east: number,
    west: number
  },
  ...otherFilters
}

// Response:
{
  success: true,
  data: {
    markers: [{
      id: string,
      position: { lat: number, lng: number },
      title: string,
      count: number  // ŸÑŸÑŸÄ clustering
    }]
  }
}
```

### 3.2 Frontend Components

#### SearchBar Component

```typescript
interface SearchBarProps {
  initialValue?: string;
  onSearch: (query: string) => void;
  onSuggestionSelect: (suggestion: string) => void;
  placeholder: string;
  autoFocus?: boolean;
}

interface SearchBarState {
  query: string;
  suggestions: string[];
  isLoading: boolean;
  showSuggestions: boolean;
}
```

#### FilterPanel Component

```typescript
interface FilterPanelProps {
  filters: FilterConfig;
  appliedFilters: AppliedFilters;
  onFilterChange: (filters: AppliedFilters) => void;
  onClearFilters: () => void;
  resultCount: number;
}

interface FilterConfig {
  salary: { min: number; max: number };
  locations: string[];
  workTypes: WorkType[];
  experienceLevels: ExperienceLevel[];
  skills: Skill[];
  companySize: CompanySize[];
}
```

#### MapView Component

```typescript
interface MapViewProps {
  jobs: JobPosting[];
  center: { lat: number; lng: number };
  zoom: number;
  onMarkerClick: (jobId: string) => void;
  onBoundsChange: (bounds: Bounds) => void;
}
```

### 3.3 Services

#### SearchService

```javascript
class SearchService {
  // ÿßŸÑÿ®ÿ≠ÿ´ ÿßŸÑŸÜÿµŸä ÿßŸÑÿ£ÿ≥ÿßÿ≥Ÿä
  async textSearch(query, options) {
    // ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ MongoDB text search
    // ŸÖÿπ ÿØÿπŸÖ ÿßŸÑÿπÿ±ÿ®Ÿäÿ© ŸàÿßŸÑÿ•ŸÜÿ¨ŸÑŸäÿ≤Ÿäÿ©
  }
  
  // ÿ™ÿ∑ÿ®ŸäŸÇ ÿßŸÑŸÅŸÑÿßÿ™ÿ±
  async applyFilters(results, filters) {
    // ÿ™ÿ∑ÿ®ŸäŸÇ ŸÅŸÑÿßÿ™ÿ± ŸÖÿ™ÿπÿØÿØÿ©
  }
  
  // ÿ≠ÿ≥ÿßÿ® ŸÜÿ≥ÿ®ÿ© ÿßŸÑŸÖÿ∑ÿßÿ®ŸÇÿ©
  calculateMatchScore(job, userProfile) {
    // ÿ≠ÿ≥ÿßÿ® ŸÜÿ≥ÿ®ÿ© ŸÖÿ∑ÿßÿ®ŸÇÿ© ÿßŸÑŸÖŸáÿßÿ±ÿßÿ™
  }
  
  // ÿßŸÑÿ™ÿ±ÿ™Ÿäÿ®
  sortResults(results, sortBy) {
    // ÿ™ÿ±ÿ™Ÿäÿ® ÿ≠ÿ≥ÿ®: relevance, date, salary, match
  }
}
```

#### FilterService

```javascript
class FilterService {
  // ŸÅŸÑÿ™ÿ±ÿ© ÿ≠ÿ≥ÿ® ÿßŸÑÿ±ÿßÿ™ÿ®
  filterBySalary(jobs, min, max) {
    return jobs.filter(job => 
      job.salary >= min && job.salary <= max
    );
  }
  
  // ŸÅŸÑÿ™ÿ±ÿ© ÿ≠ÿ≥ÿ® ÿßŸÑŸÖŸàŸÇÿπ
  filterByLocation(jobs, location) {
    // ÿØÿπŸÖ ÿßŸÑÿ®ÿ≠ÿ´ ÿ®ÿßŸÑŸÖÿØŸäŸÜÿ© ÿ£Ÿà ÿßŸÑÿØŸàŸÑÿ©
  }
  
  // ŸÅŸÑÿ™ÿ±ÿ© ÿ≠ÿ≥ÿ® ÿßŸÑŸÖŸáÿßÿ±ÿßÿ™ ŸÖÿπ ŸÖŸÜÿ∑ŸÇ AND/OR
  filterBySkills(jobs, skills, logic) {
    if (logic === 'AND') {
      // Ÿäÿ¨ÿ® ÿ™ŸàŸÅÿ± ÿ¨ŸÖŸäÿπ ÿßŸÑŸÖŸáÿßÿ±ÿßÿ™
      return jobs.filter(job =>
        skills.every(skill => job.skills.includes(skill))
      );
    } else {
      // ŸäŸÉŸÅŸä ÿ™ŸàŸÅÿ± ÿ£Ÿä ŸÖŸáÿßÿ±ÿ©
      return jobs.filter(job =>
        skills.some(skill => job.skills.includes(skill))
      );
    }
  }
  
  // ŸÅŸÑÿ™ÿ±ÿ© ÿ≠ÿ≥ÿ® ÿßŸÑÿ™ÿßÿ±ŸäÿÆ
  filterByDate(jobs, dateRange) {
    // today, week, month, all
  }
}
```

#### MatchingEngine

```javascript
class MatchingEngine {
  // ÿ≠ÿ≥ÿßÿ® ŸÜÿ≥ÿ®ÿ© ÿßŸÑŸÖÿ∑ÿßÿ®ŸÇÿ©
  calculateMatchPercentage(jobSkills, userSkills) {
    const matchedSkills = jobSkills.filter(skill =>
      userSkills.includes(skill)
    );
    return (matchedSkills.length / jobSkills.length) * 100;
  }
  
  // ÿ™ÿ±ÿ™Ÿäÿ® ÿ≠ÿ≥ÿ® ÿßŸÑŸÖÿ∑ÿßÿ®ŸÇÿ©
  rankByMatch(jobs, userProfile) {
    return jobs.map(job => ({
      ...job,
      matchScore: this.calculateMatchPercentage(
        job.skills,
        userProfile.skills
      )
    })).sort((a, b) => b.matchScore - a.matchScore);
  }
}
```

#### AlertService

```javascript
class AlertService {
  // ŸÅÿ≠ÿµ ÿßŸÑŸÜÿ™ÿßÿ¶ÿ¨ ÿßŸÑÿ¨ÿØŸäÿØÿ©
  async checkNewResults(savedSearch) {
    const lastCheck = savedSearch.lastChecked;
    const newJobs = await this.searchNewJobs(
      savedSearch.searchParams,
      lastCheck
    );
    
    if (newJobs.length > 0) {
      await this.sendAlert(savedSearch.userId, newJobs);
    }
  }
  
  // ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑÿ™ŸÜÿ®ŸäŸá
  async sendAlert(userId, jobs) {
    // ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ŸÜÿ∏ÿßŸÖ ÿßŸÑÿ•ÿ¥ÿπÿßÿ±ÿßÿ™ ÿßŸÑŸÖŸàÿ¨ŸàÿØ
    await notificationService.create({
      userId,
      type: 'search_alert',
      title: 'Ÿàÿ∏ÿßÿ¶ŸÅ ÿ¨ÿØŸäÿØÿ© ÿ™ÿ∑ÿßÿ®ŸÇ ÿ®ÿ≠ÿ´ŸÉ',
      message: `ÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ${jobs.length} Ÿàÿ∏ŸäŸÅÿ© ÿ¨ÿØŸäÿØÿ©`,
      data: { jobs }
    });
  }
  
  // ÿ¨ÿØŸàŸÑÿ© ÿßŸÑÿ™ŸÜÿ®ŸäŸáÿßÿ™
  scheduleAlerts() {
    // ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ cron jobs ŸÑŸÑÿ™ŸÜÿ®ŸäŸáÿßÿ™ ÿßŸÑŸäŸàŸÖŸäÿ©/ÿßŸÑÿ£ÿ≥ÿ®ŸàÿπŸäÿ©
  }
}
```

---

## 4. Data Models

### 4.1 SavedSearch Model

```javascript
const SavedSearchSchema = new mongoose.Schema({
  userId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true,
    index: true
  },
  name: {
    type: String,
    required: true,
    trim: true,
    maxlength: 100
  },
  searchType: {
    type: String,
    enum: ['jobs', 'courses'],
    required: true
  },
  searchParams: {
    query: String,
    location: String,
    salaryMin: Number,
    salaryMax: Number,
    workType: [String],
    experienceLevel: [String],
    skills: [String],
    skillsLogic: {
      type: String,
      enum: ['AND', 'OR'],
      default: 'OR'
    },
    datePosted: String,
    companySize: [String]
  },
  alertEnabled: {
    type: Boolean,
    default: false
  },
  alertFrequency: {
    type: String,
    enum: ['instant', 'daily', 'weekly'],
    default: 'instant'
  },
  notificationMethod: {
    type: String,
    enum: ['push', 'email', 'both'],
    default: 'push'
  },
  lastChecked: {
    type: Date,
    default: Date.now
  },
  resultCount: {
    type: Number,
    default: 0
  },
  createdAt: {
    type: Date,
    default: Date.now
  },
  updatedAt: {
    type: Date,
    default: Date.now
  }
});

// Indexes
SavedSearchSchema.index({ userId: 1, createdAt: -1 });
SavedSearchSchema.index({ alertEnabled: 1, lastChecked: 1 });

// Limit: 10 saved searches per user
SavedSearchSchema.pre('save', async function(next) {
  if (this.isNew) {
    const count = await this.constructor.countDocuments({
      userId: this.userId
    });
    if (count >= 10) {
      throw new Error('Maximum 10 saved searches allowed per user');
    }
  }
  next();
});
```

### 4.2 SearchAlert Model

```javascript
const SearchAlertSchema = new mongoose.Schema({
  userId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true,
    index: true
  },
  savedSearchId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'SavedSearch',
    required: true
  },
  frequency: {
    type: String,
    enum: ['instant', 'daily', 'weekly'],
    required: true
  },
  notificationMethod: {
    type: String,
    enum: ['push', 'email', 'both'],
    required: true
  },
  isActive: {
    type: Boolean,
    default: true
  },
  lastTriggered: {
    type: Date
  },
  triggerCount: {
    type: Number,
    default: 0
  },
  createdAt: {
    type: Date,
    default: Date.now
  }
});

// Indexes
SearchAlertSchema.index({ userId: 1, isActive: 1 });
SearchAlertSchema.index({ frequency: 1, lastTriggered: 1 });
```

### 4.3 SearchHistory Model

```javascript
const SearchHistorySchema = new mongoose.Schema({
  userId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true,
    index: true
  },
  query: {
    type: String,
    required: true
  },
  searchType: {
    type: String,
    enum: ['jobs', 'courses'],
    required: true
  },
  filters: {
    type: mongoose.Schema.Types.Mixed
  },
  resultCount: {
    type: Number,
    default: 0
  },
  timestamp: {
    type: Date,
    default: Date.now,
    index: true
  }
});

// TTL Index: ÿ≠ÿ∞ŸÅ ÿßŸÑÿ≥ÿ¨ŸÑÿßÿ™ ÿ®ÿπÿØ 90 ŸäŸàŸÖ
SearchHistorySchema.index(
  { timestamp: 1 },
  { expireAfterSeconds: 7776000 }
);
```

### 4.4 Database Indexes

#### JobPosting Indexes

```javascript
// Text index ŸÑŸÑÿ®ÿ≠ÿ´ ÿßŸÑŸÜÿµŸä
JobPostingSchema.index({
  title: 'text',
  description: 'text',
  'company.name': 'text',
  skills: 'text'
}, {
  weights: {
    title: 10,
    skills: 5,
    'company.name': 3,
    description: 1
  },
  default_language: 'arabic'
});

// Geo index ŸÑŸÑÿ®ÿ≠ÿ´ ÿßŸÑÿ¨ÿ∫ÿ±ÿßŸÅŸä
JobPostingSchema.index({
  'location.coordinates': '2dsphere'
});

// Compound indexes ŸÑŸÑŸÅŸÑÿßÿ™ÿ±
JobPostingSchema.index({
  status: 1,
  createdAt: -1
});

JobPostingSchema.index({
  'salary.min': 1,
  'salary.max': 1
});

JobPostingSchema.index({
  workType: 1,
  experienceLevel: 1
});

JobPostingSchema.index({
  skills: 1
});
```

---

## 5. Correctness Properties

*A property is a characteristic or behavior that should hold true across all valid executions of a system‚Äîessentially, a formal statement about what the system should do. Properties serve as the bridge between human-readable specifications and machine-verifiable correctness guarantees.*

### Property 1: Multi-field Search Coverage

*For any* search query and any collection of job postings, when searching across all specified fields (title, description, skills, company name), the results should include all jobs where the query matches any of these fields.

**Validates: Requirements 1.1**

### Property 2: Autocomplete Threshold

*For any* search input text, if the text length is less than 3 characters, the system should return zero suggestions; if the text length is 3 or more characters, the system should return at least one suggestion (if matching data exists).

**Validates: Requirements 1.3**

### Property 3: Bilingual Search Support

*For any* search query in Arabic or English, the system should return relevant results in the same language, demonstrating that both languages are fully supported.

**Validates: Requirements 1.4**

### Property 4: Multiple Filter Application

*For any* combination of filters (salary, location, work type, experience, skills, date, company size), when applied simultaneously, the results should satisfy all filter conditions (AND logic between different filter types).

**Validates: Requirements 2.2**

### Property 5: Filter URL Persistence (Round-trip)

*For any* set of applied filters, when serialized to URL parameters and then deserialized back, the resulting filter object should be equivalent to the original filter object.

**Validates: Requirements 2.3**

### Property 6: Result Count Accuracy

*For any* applied filter and any dataset, the result count displayed should exactly equal the number of results returned by the search query.

**Validates: Requirements 2.4**

### Property 7: Clear Filters Reset

*For any* state with applied filters, when the "clear filters" action is triggered, the resulting state should be equivalent to the default state with no filters applied.

**Validates: Requirements 2.5**

### Property 8: Saved Search Limit Enforcement

*For any* user, when attempting to save more than 10 search operations, the system should reject the 11th save attempt and maintain exactly 10 or fewer saved searches.

**Validates: Requirements 3.1**

### Property 9: Saved Search Round-trip

*For any* search operation (including query and all filters), when saved and then retrieved, the retrieved search should contain all the original search parameters unchanged.

**Validates: Requirements 3.2**

### Property 10: Save Operation Notifications

*For any* save, update, or delete operation on a saved search, the system should generate exactly one notification for that operation.

**Validates: Requirements 3.4**

### Property 11: Alert Triggering on New Match

*For any* active alert with specific search criteria, when a new job posting is created that matches those criteria, the system should trigger exactly one alert notification.

**Validates: Requirements 4.1**

### Property 12: Alert Toggle Behavior

*For any* saved search with an alert, when the alert is enabled, matching jobs should trigger notifications; when disabled, no notifications should be sent for matching jobs.

**Validates: Requirements 4.2**

### Property 13: Alert Notification Link Validity

*For any* alert notification generated, the notification should contain a valid direct link to the job posting that triggered the alert.

**Validates: Requirements 4.3**

### Property 14: Alert Deduplication

*For any* job posting, when it matches multiple times with the same alert criteria (e.g., re-indexed or updated), the system should send at most one alert notification for that job.

**Validates: Requirements 4.4**

### Property 15: Map Marker Completeness

*For any* set of job postings with valid geographic coordinates, when displayed on the map, the number of markers (or marker clusters) should represent all jobs in the dataset.

**Validates: Requirements 5.1**

### Property 16: Geographic Boundary Filtering

*For any* geographic boundary (circle or rectangle) drawn on the map, all returned job results should have coordinates that fall within that boundary.

**Validates: Requirements 5.2**

### Property 17: Map Bilingual Support

*For any* map interface element (labels, tooltips, controls), when the language is switched between Arabic and English, all text should display correctly in the selected language.

**Validates: Requirements 5.4**

### Property 18: Skills Logic (AND/OR)

*For any* set of selected skills and any collection of jobs:
- When using AND logic, all returned jobs should contain all selected skills
- When using OR logic, all returned jobs should contain at least one of the selected skills

**Validates: Requirements 6.2**

### Property 19: Match Score Sorting

*For any* search results with calculated match scores, the results should be sorted in descending order by match score (highest match first).

**Validates: Requirements 6.3**

### Property 20: Match Percentage Calculation

*For any* job posting with required skills and any user profile with skills, the match percentage should equal (number of matching skills / total job required skills) √ó 100.

**Validates: Requirements 6.4**

---

## 6. Error Handling

### 6.1 Search Errors

```javascript
// Empty query handling
if (!query || query.trim().length === 0) {
  return {
    success: true,
    data: {
      results: [],
      total: 0,
      message: 'Please enter a search query'
    }
  };
}

// Invalid filter values
if (salaryMin < 0 || salaryMax < salaryMin) {
  throw new ValidationError('Invalid salary range');
}

// Database errors
try {
  const results = await JobPosting.find(searchQuery);
} catch (error) {
  logger.error('Search query failed:', error);
  throw new DatabaseError('Search operation failed');
}
```

### 6.2 Saved Search Errors

```javascript
// Limit exceeded
if (userSavedSearchCount >= 10) {
  throw new LimitExceededError(
    'Maximum 10 saved searches allowed per user'
  );
}

// Duplicate name
const existing = await SavedSearch.findOne({
  userId,
  name: searchName
});
if (existing) {
  throw new DuplicateError('Search name already exists');
}

// Not found
const savedSearch = await SavedSearch.findById(id);
if (!savedSearch) {
  throw new NotFoundError('Saved search not found');
}

// Unauthorized access
if (savedSearch.userId.toString() !== userId) {
  throw new UnauthorizedError('Access denied');
}
```

### 6.3 Alert Errors

```javascript
// Invalid frequency
if (!['instant', 'daily', 'weekly'].includes(frequency)) {
  throw new ValidationError('Invalid alert frequency');
}

// Alert already exists
const existing = await SearchAlert.findOne({
  userId,
  savedSearchId
});
if (existing) {
  throw new DuplicateError('Alert already exists for this search');
}

// Failed to send notification
try {
  await notificationService.send(notification);
} catch (error) {
  logger.error('Failed to send alert:', error);
  // Don't throw - log and continue
  // Retry mechanism should handle this
}
```

### 6.4 Map Errors

```javascript
// Invalid coordinates
if (!isValidLatitude(lat) || !isValidLongitude(lng)) {
  throw new ValidationError('Invalid coordinates');
}

// Invalid bounds
if (bounds.north <= bounds.south || 
    bounds.east <= bounds.west) {
  throw new ValidationError('Invalid map bounds');
}

// Geocoding failure
try {
  const coords = await geocodeAddress(address);
} catch (error) {
  logger.warn('Geocoding failed:', error);
  // Return job without coordinates
  return { ...job, coordinates: null };
}
```

### 6.5 General Error Responses

```javascript
// Standard error response format
{
  success: false,
  error: {
    code: 'ERROR_CODE',
    message: 'User-friendly error message',
    details: {} // Optional technical details
  }
}

// Error codes
const ErrorCodes = {
  VALIDATION_ERROR: 'VALIDATION_ERROR',
  NOT_FOUND: 'NOT_FOUND',
  UNAUTHORIZED: 'UNAUTHORIZED',
  LIMIT_EXCEEDED: 'LIMIT_EXCEEDED',
  DUPLICATE: 'DUPLICATE',
  DATABASE_ERROR: 'DATABASE_ERROR',
  EXTERNAL_SERVICE_ERROR: 'EXTERNAL_SERVICE_ERROR'
};
```

---

## 7. Testing Strategy

### 7.1 Dual Testing Approach

This system requires both unit tests and property-based tests for comprehensive coverage:

- **Unit tests**: Verify specific examples, edge cases, and error conditions
- **Property tests**: Verify universal properties across all inputs
- Together they provide comprehensive coverage where unit tests catch concrete bugs and property tests verify general correctness

### 7.2 Property-Based Testing

**Library**: We will use **fast-check** for JavaScript/TypeScript property-based testing.

**Configuration**:
- Minimum 100 iterations per property test
- Each test must reference its design document property
- Tag format: `Feature: advanced-search-filter, Property {number}: {property_text}`

**Example Property Test**:

```javascript
import fc from 'fast-check';

describe('Advanced Search Filter - Property Tests', () => {
  
  // Feature: advanced-search-filter, Property 1: Multi-field Search Coverage
  it('should search across all specified fields', async () => {
    await fc.assert(
      fc.asyncProperty(
        fc.string({ minLength: 1, maxLength: 50 }),
        fc.array(jobPostingArbitrary()),
        async (query, jobs) => {
          // Insert test data
          await JobPosting.insertMany(jobs);
          
          // Perform search
          const results = await searchService.search(query);
          
          // Verify: results include all jobs matching in any field
          const expected = jobs.filter(job =>
            job.title.includes(query) ||
            job.description.includes(query) ||
            job.skills.some(s => s.includes(query)) ||
            job.company.name.includes(query)
          );
          
          expect(results.length).toBeGreaterThanOrEqual(expected.length);
        }
      ),
      { numRuns: 100 }
    );
  });
  
  // Feature: advanced-search-filter, Property 5: Filter URL Persistence
  it('should preserve filters through URL round-trip', () => {
    fc.assert(
      fc.property(
        filterArbitrary(),
        (filters) => {
          // Serialize to URL
          const url = serializeFiltersToURL(filters);
          
          // Deserialize from URL
          const restored = deserializeFiltersFromURL(url);
          
          // Verify: restored equals original
          expect(restored).toEqual(filters);
        }
      ),
      { numRuns: 100 }
    );
  });
  
  // Feature: advanced-search-filter, Property 20: Match Percentage Calculation
  it('should calculate correct match percentage', () => {
    fc.assert(
      fc.property(
        fc.array(fc.string(), { minLength: 1, maxLength: 10 }),
        fc.array(fc.string(), { minLength: 1, maxLength: 10 }),
        (jobSkills, userSkills) => {
          const matchScore = matchingEngine.calculateMatchPercentage(
            jobSkills,
            userSkills
          );
          
          const matchedCount = jobSkills.filter(s =>
            userSkills.includes(s)
          ).length;
          
          const expected = (matchedCount / jobSkills.length) * 100;
          
          expect(matchScore).toBe(expected);
        }
      ),
      { numRuns: 100 }
    );
  });
});
```

### 7.3 Unit Testing

**Focus Areas**:
- Specific filter combinations
- Edge cases (empty results, single result, maximum results)
- Error conditions (invalid input, database errors)
- Integration between components

**Example Unit Tests**:

```javascript
describe('SearchService - Unit Tests', () => {
  
  it('should return empty results for empty query', async () => {
    const results = await searchService.search('');
    expect(results.data.results).toEqual([]);
    expect(results.data.total).toBe(0);
  });
  
  it('should filter by salary range correctly', async () => {
    const jobs = await createTestJobs([
      { salary: 5000 },
      { salary: 10000 },
      { salary: 15000 }
    ]);
    
    const results = await searchService.search('', {
      salaryMin: 8000,
      salaryMax: 12000
    });
    
    expect(results.data.results).toHaveLength(1);
    expect(results.data.results[0].salary).toBe(10000);
  });
  
  it('should throw error when saving 11th search', async () => {
    const userId = 'test-user';
    
    // Create 10 saved searches
    for (let i = 0; i < 10; i++) {
      await savedSearchService.create(userId, {
        name: `Search ${i}`,
        searchParams: {}
      });
    }
    
    // Attempt 11th
    await expect(
      savedSearchService.create(userId, {
        name: 'Search 11',
        searchParams: {}
      })
    ).rejects.toThrow('Maximum 10 saved searches allowed');
  });
  
  it('should apply AND logic for skills correctly', async () => {
    const jobs = await createTestJobs([
      { skills: ['JavaScript', 'React', 'Node.js'] },
      { skills: ['JavaScript', 'React'] },
      { skills: ['JavaScript'] }
    ]);
    
    const results = await searchService.search('', {
      skills: ['JavaScript', 'React'],
      skillsLogic: 'AND'
    });
    
    expect(results.data.results).toHaveLength(2);
    results.data.results.forEach(job => {
      expect(job.skills).toContain('JavaScript');
      expect(job.skills).toContain('React');
    });
  });
});
```

### 7.4 Integration Testing

```javascript
describe('Search System - Integration Tests', () => {
  
  it('should handle complete search workflow', async () => {
    // 1. Create user
    const user = await createTestUser();
    
    // 2. Perform search
    const searchResults = await request(app)
      .get('/api/search/jobs')
      .query({ q: 'developer', location: 'Cairo' })
      .set('Authorization', `Bearer ${user.token}`);
    
    expect(searchResults.status).toBe(200);
    expect(searchResults.body.data.results).toBeDefined();
    
    // 3. Save search
    const savedSearch = await request(app)
      .post('/api/search/saved')
      .set('Authorization', `Bearer ${user.token}`)
      .send({
        name: 'Cairo Developer Jobs',
        searchParams: { q: 'developer', location: 'Cairo' }
      });
    
    expect(savedSearch.status).toBe(201);
    
    // 4. Enable alert
    const alert = await request(app)
      .post('/api/search/alerts')
      .set('Authorization', `Bearer ${user.token}`)
      .send({
        savedSearchId: savedSearch.body.data._id,
        frequency: 'instant'
      });
    
    expect(alert.status).toBe(201);
    
    // 5. Create matching job
    const job = await createTestJob({
      title: 'Senior Developer',
      location: { city: 'Cairo' }
    });
    
    // 6. Verify alert was sent
    const notifications = await Notification.find({
      userId: user._id,
      type: 'search_alert'
    });
    
    expect(notifications).toHaveLength(1);
    expect(notifications[0].data.jobs[0]._id).toEqual(job._id);
  });
});
```

### 7.5 Performance Testing

```javascript
describe('Search Performance', () => {
  
  it('should return results within 500ms', async () => {
    // Create large dataset
    await createTestJobs(1000);
    
    const start = Date.now();
    await searchService.search('developer');
    const duration = Date.now() - start;
    
    expect(duration).toBeLessThan(500);
  });
  
  it('should handle concurrent searches efficiently', async () => {
    const searches = Array(50).fill(null).map((_, i) =>
      searchService.search(`query${i}`)
    );
    
    const start = Date.now();
    await Promise.all(searches);
    const duration = Date.now() - start;
    
    // Average should be under 500ms per search
    expect(duration / 50).toBeLessThan(500);
  });
});
```

---

## 8. Performance Optimization

### 8.1 Database Optimization

```javascript
// Use lean() for read-only queries
const results = await JobPosting
  .find(query)
  .lean()
  .limit(20);

// Use select() to limit fields
const results = await JobPosting
  .find(query)
  .select('title company.name location salary')
  .lean();

// Use explain() to analyze queries
const explanation = await JobPosting
  .find(query)
  .explain('executionStats');
```

### 8.2 Caching Strategy

```javascript
// Cache popular searches (Redis)
const cacheKey = `search:${JSON.stringify(searchParams)}`;
const cached = await redis.get(cacheKey);

if (cached) {
  return JSON.parse(cached);
}

const results = await performSearch(searchParams);
await redis.setex(cacheKey, 300, JSON.stringify(results)); // 5 min TTL

return results;
```

### 8.3 Pagination

```javascript
// Cursor-based pagination for better performance
const results = await JobPosting
  .find({
    ...query,
    _id: { $gt: lastSeenId }
  })
  .sort({ _id: 1 })
  .limit(20);
```

### 8.4 Debouncing

```javascript
// Frontend: Debounce autocomplete requests
const debouncedSearch = debounce(async (query) => {
  const suggestions = await api.getAutocomplete(query);
  setSuggestions(suggestions);
}, 300);
```

---

## 9. Security Considerations

### 9.1 Input Validation

```javascript
// Sanitize search queries
const sanitizedQuery = validator.escape(query);

// Validate filter values
const schema = Joi.object({
  q: Joi.string().max(200),
  salaryMin: Joi.number().min(0),
  salaryMax: Joi.number().min(0),
  skills: Joi.array().items(Joi.string()).max(20)
});
```

### 9.2 Rate Limiting

```javascript
// Limit search requests per user
const limiter = rateLimit({
  windowMs: 60 * 1000, // 1 minute
  max: 30, // 30 requests per minute
  message: 'Too many search requests'
});

app.use('/api/search', limiter);
```

### 9.3 Authorization

```javascript
// Verify user owns saved search
const savedSearch = await SavedSearch.findById(id);
if (savedSearch.userId.toString() !== req.user._id.toString()) {
  throw new UnauthorizedError('Access denied');
}
```

---

## 10. Future Enhancements

1. **AI-Powered Recommendations**: Use machine learning to suggest relevant jobs
2. **Voice Search**: Support voice input for search queries
3. **Advanced Analytics**: Track search patterns and popular filters
4. **Collaborative Filtering**: "Users who searched for X also searched for Y"
5. **Saved Search Sharing**: Allow users to share saved searches with others
6. **Export Results**: Export search results to PDF/CSV
7. **Mobile App Integration**: Native mobile search experience
8. **Real-time Updates**: WebSocket for instant result updates

---

**ÿ™ÿßÿ±ŸäÿÆ ÿßŸÑÿ•ŸÜÿ¥ÿßÿ°**: 2026-02-17  
**ÿ¢ÿÆÿ± ÿ™ÿ≠ÿØŸäÿ´**: 2026-02-17  
**ÿßŸÑÿ≠ÿßŸÑÿ©**: ÿ¨ÿßŸáÿ≤ ŸÑŸÑŸÖÿ±ÿßÿ¨ÿπÿ©

