/* eslint-disable no-restricted-globals */
/* global self, caches, clients */

// Import Workbox from CDN for service worker context
importScripts('https://storage.googleapis.com/workbox-cdn/releases/7.0.0/workbox-sw.js');

const { clientsClaim } = workbox.core;
const { ExpirationPlugin } = workbox.expiration;
const { precacheAndRoute } = workbox.precaching;
const { registerRoute } = workbox.routing;
const { CacheFirst, NetworkFirst } = workbox.strategies;

// Claim clients immediately
clientsClaim();

// Precache critical assets explicitly (Task 3.2.4)
// These are the most important files needed for the app to function
const CRITICAL_ASSETS = [
  '/', // index.html
  '/index.html',
  '/manifest.json',
  '/logo.png',
  '/offline.html',
];

// Precache all assets generated by the build process
// This includes main.js, main.css, and other build outputs
precacheAndRoute(self.__WB_MANIFEST);

// Explicitly precache critical assets during install
// This ensures they're available immediately, even before first visit
self.addEventListener('install', (event) => {
  event.waitUntil(
    Promise.all([
      // Precache critical assets
      caches.open('critical-assets-v1').then((cache) => {
        console.log('Precaching critical assets:', CRITICAL_ASSETS);
        return cache.addAll(CRITICAL_ASSETS).catch((error) => {
          console.error('Failed to precache critical assets:', error);
          // Don't fail installation if some assets are missing
          return Promise.resolve();
        });
      }),
      // Precache offline fallback page
      caches.open('offline-fallback').then((cache) => {
        console.log('Precaching offline fallback page');
        return cache.add('/offline.html').catch((error) => {
          console.error('Failed to precache offline page:', error);
          return Promise.resolve();
        });
      })
    ])
  );
});

// Cache static assets (JS, CSS, fonts) with CacheFirst strategy
// 30-day expiration as per FR-PWA-8
registerRoute(
  ({ request }) => 
    request.destination === 'script' ||
    request.destination === 'style' ||
    request.destination === 'font',
  new CacheFirst({
    cacheName: 'static-assets',
    plugins: [
      new ExpirationPlugin({
        maxAgeSeconds: 30 * 24 * 60 * 60, // 30 days
        maxEntries: 60,
      }),
    ],
  })
);

// Cache images with CacheFirst strategy
// 50MB size limit enforced through browser quota management and purgeOnQuotaError
// Average image size ~500KB, so maxEntries: 100 â‰ˆ 50MB
// As per FR-PWA-3 and task 3.2.3
registerRoute(
  ({ request }) => request.destination === 'image',
  new CacheFirst({
    cacheName: 'images',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 100, // ~50MB with average 500KB per image
        maxAgeSeconds: 30 * 24 * 60 * 60, // 30 days
        purgeOnQuotaError: true, // Auto-cleanup when quota exceeded (enforces 50MB limit)
      }),
    ],
  })
);

// Cache API calls with NetworkFirst strategy
// 5-minute timeout as per design document
registerRoute(
  ({ url }) => url.pathname.startsWith('/api/'),
  new NetworkFirst({
    cacheName: 'api-cache',
    networkTimeoutSeconds: 5 * 60, // 5 minutes
    plugins: [
      new ExpirationPlugin({
        maxEntries: 50,
        maxAgeSeconds: 5 * 60, // 5 minutes
      }),
    ],
  })
);

// Cache navigation requests with NetworkFirst
registerRoute(
  ({ request }) => request.mode === 'navigate',
  new NetworkFirst({
    cacheName: 'pages',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 50,
        maxAgeSeconds: 24 * 60 * 60, // 24 hours
      }),
    ],
  })
);

// Fallback to offline page when offline and page not cached
// As per FR-PWA-3
const FALLBACK_HTML_URL = '/offline.html';

self.addEventListener('fetch', (event) => {
  if (event.request.mode === 'navigate') {
    event.respondWith(
      fetch(event.request).catch(() => {
        return caches.match(FALLBACK_HTML_URL);
      })
    );
  }
});

// Listen for skip waiting message
self.addEventListener('message', (event) => {
  if (event.data && event.data.type === 'SKIP_WAITING') {
    self.skipWaiting();
  }
});

// Push notification support (FR-PWA-10)
// Integration with existing Pusher system
self.addEventListener('push', (event) => {
  const data = event.data ? event.data.json() : {};
  const title = data.title || 'Careerak Notification';
  const options = {
    body: data.body || 'You have a new notification',
    icon: '/logo.png',
    badge: '/logo.png',
    data: data.data || {},
    actions: data.actions || [],
    tag: data.tag || 'default',
    requireInteraction: data.requireInteraction || false,
  };

  event.waitUntil(
    self.registration.showNotification(title, options)
  );
});

// Handle notification clicks
self.addEventListener('notificationclick', (event) => {
  event.notification.close();

  const urlToOpen = event.notification.data?.url || '/';

  event.waitUntil(
    clients.matchAll({ type: 'window', includeUncontrolled: true })
      .then((clientList) => {
        // Check if there's already a window open
        for (const client of clientList) {
          if (client.url === urlToOpen && 'focus' in client) {
            return client.focus();
          }
        }
        // Open new window if none exists
        if (clients.openWindow) {
          return clients.openWindow(urlToOpen);
        }
      })
  );
});

// Background sync for offline requests (FR-PWA-9)
self.addEventListener('sync', (event) => {
  if (event.tag === 'sync-requests') {
    event.waitUntil(syncRequests());
  }
});

async function syncRequests() {
  const cache = await caches.open('failed-requests');
  const requests = await cache.keys();
  
  return Promise.all(
    requests.map(async (request) => {
      try {
        const response = await fetch(request);
        if (response.ok) {
          await cache.delete(request);
        }
        return response;
      } catch (error) {
        console.error('Failed to sync request:', error);
        return null;
      }
    })
  );
}
