/* eslint-disable no-restricted-globals */
/* global self, caches, clients */

// Import Workbox from CDN for service worker context
importScripts('https://storage.googleapis.com/workbox-cdn/releases/7.0.0/workbox-sw.js');

const { clientsClaim } = workbox.core;
const { ExpirationPlugin } = workbox.expiration;
const { precacheAndRoute } = workbox.precaching;
const { registerRoute } = workbox.routing;
const { CacheFirst, NetworkFirst } = workbox.strategies;

// Claim clients immediately
clientsClaim();

// Precache critical assets explicitly (Task 3.2.4)
// These are the most important files needed for the app to function
const CRITICAL_ASSETS = [
  '/', // index.html
  '/index.html',
  '/manifest.json',
  '/logo.png',
  '/offline.html',
];

// Precache all assets generated by the build process
// This includes main.js, main.css, and other build outputs
precacheAndRoute(self.__WB_MANIFEST);

// Explicitly precache critical assets during install
// This ensures they're available immediately, even before first visit
self.addEventListener('install', (event) => {
  event.waitUntil(
    Promise.all([
      // Precache critical assets
      caches.open('critical-assets-v1').then((cache) => {
        console.log('Precaching critical assets:', CRITICAL_ASSETS);
        return cache.addAll(CRITICAL_ASSETS).catch((error) => {
          console.error('Failed to precache critical assets:', error);
          // Don't fail installation if some assets are missing
          return Promise.resolve();
        });
      }),
      // Precache offline fallback page
      caches.open('offline-fallback').then((cache) => {
        console.log('Precaching offline fallback page');
        return cache.add('/offline.html').catch((error) => {
          console.error('Failed to precache offline page:', error);
          return Promise.resolve();
        });
      })
    ])
  );
});

// Cache static assets (JS, CSS, fonts) with CacheFirst strategy
// 30-day expiration as per FR-PWA-8
registerRoute(
  ({ request }) => 
    request.destination === 'script' ||
    request.destination === 'style' ||
    request.destination === 'font',
  new CacheFirst({
    cacheName: 'static-assets',
    plugins: [
      new ExpirationPlugin({
        maxAgeSeconds: 30 * 24 * 60 * 60, // 30 days
        maxEntries: 60,
      }),
    ],
  })
);

// Cache images with CacheFirst strategy
// 50MB size limit enforced through browser quota management and purgeOnQuotaError
// Average image size ~500KB, so maxEntries: 100 â‰ˆ 50MB
// As per FR-PWA-3 and task 3.2.3
registerRoute(
  ({ request }) => request.destination === 'image',
  new CacheFirst({
    cacheName: 'images',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 100, // ~50MB with average 500KB per image
        maxAgeSeconds: 30 * 24 * 60 * 60, // 30 days
        purgeOnQuotaError: true, // Auto-cleanup when quota exceeded (enforces 50MB limit)
      }),
    ],
  })
);

// Cache API calls with NetworkFirst strategy
// 5-minute timeout as per design document
registerRoute(
  ({ url }) => url.pathname.startsWith('/api/'),
  new NetworkFirst({
    cacheName: 'api-cache',
    networkTimeoutSeconds: 5 * 60, // 5 minutes
    plugins: [
      new ExpirationPlugin({
        maxEntries: 50,
        maxAgeSeconds: 5 * 60, // 5 minutes
      }),
    ],
  })
);

// Cache navigation requests with NetworkFirst
registerRoute(
  ({ request }) => request.mode === 'navigate',
  new NetworkFirst({
    cacheName: 'pages',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 50,
        maxAgeSeconds: 24 * 60 * 60, // 24 hours
      }),
    ],
  })
);

// Fallback to offline page when offline and page not cached
// As per FR-PWA-3
const FALLBACK_HTML_URL = '/offline.html';

self.addEventListener('fetch', (event) => {
  if (event.request.mode === 'navigate') {
    event.respondWith(
      fetch(event.request).catch(() => {
        return caches.match(FALLBACK_HTML_URL);
      })
    );
  }
});

// Push notification support (FR-PWA-10)
// Integration with existing Pusher system
// Task 3.5.4: Display notifications with actions
self.addEventListener('push', (event) => {
  const data = event.data ? event.data.json() : {};
  const title = data.title || 'Careerak Notification';
  
  // Determine notification type and set appropriate actions
  const notificationType = data.type || 'system';
  const actions = getNotificationActions(notificationType, data);
  
  const options = {
    body: data.body || 'You have a new notification',
    icon: data.icon || '/logo.png',
    badge: '/logo.png',
    data: {
      ...data.data,
      type: notificationType,
      url: data.url || '/',
    },
    actions: actions,
    tag: data.tag || `notification-${Date.now()}`,
    requireInteraction: data.requireInteraction || false,
    vibrate: [200, 100, 200], // Vibration pattern
    timestamp: Date.now(),
    silent: data.silent || false,
  };

  event.waitUntil(
    self.registration.showNotification(title, options)
  );
});

// Helper function to get notification actions based on type
// Task 3.5.4: Define actions for different notification types
function getNotificationActions(type, data) {
  switch (type) {
    case 'job_match':
      return [
        { action: 'view', title: 'View Job', icon: '/icons/view.png' },
        { action: 'apply', title: 'Apply Now', icon: '/icons/apply.png' },
      ];
    
    case 'application_accepted':
      return [
        { action: 'view', title: 'View Details', icon: '/icons/view.png' },
        { action: 'message', title: 'Send Message', icon: '/icons/message.png' },
      ];
    
    case 'application_rejected':
      return [
        { action: 'view', title: 'View Feedback', icon: '/icons/view.png' },
        { action: 'dismiss', title: 'Dismiss', icon: '/icons/close.png' },
      ];
    
    case 'application_reviewed':
      return [
        { action: 'view', title: 'View Status', icon: '/icons/view.png' },
        { action: 'dismiss', title: 'Dismiss', icon: '/icons/close.png' },
      ];
    
    case 'new_application':
      return [
        { action: 'review', title: 'Review Now', icon: '/icons/review.png' },
        { action: 'later', title: 'Review Later', icon: '/icons/clock.png' },
      ];
    
    case 'job_closed':
      return [
        { action: 'view', title: 'View Details', icon: '/icons/view.png' },
        { action: 'dismiss', title: 'Dismiss', icon: '/icons/close.png' },
      ];
    
    case 'course_match':
      return [
        { action: 'view', title: 'View Course', icon: '/icons/view.png' },
        { action: 'enroll', title: 'Enroll Now', icon: '/icons/enroll.png' },
      ];
    
    case 'new_message':
      return [
        { action: 'reply', title: 'Reply', icon: '/icons/reply.png' },
        { action: 'view', title: 'View Chat', icon: '/icons/message.png' },
      ];
    
    case 'system':
    default:
      return [
        { action: 'view', title: 'View', icon: '/icons/view.png' },
        { action: 'dismiss', title: 'Dismiss', icon: '/icons/close.png' },
      ];
  }
}

// Listen for messages from the main thread (Pusher integration)
// Task 3.5.4: Support actions in Pusher notifications
self.addEventListener('message', (event) => {
  if (event.data && event.data.type === 'PUSH_NOTIFICATION') {
    const { notification } = event.data;
    
    // Determine notification type and get appropriate actions
    const notificationType = notification.type || 'system';
    const actions = notification.actions || getNotificationActions(notificationType, notification);
    
    event.waitUntil(
      self.registration.showNotification(
        notification.title,
        {
          body: notification.body,
          icon: notification.icon || '/logo.png',
          badge: notification.badge || '/logo.png',
          data: {
            ...notification.data,
            type: notificationType,
            url: notification.url || '/',
          },
          actions: actions,
          tag: notification.tag || `pusher-${Date.now()}`,
          requireInteraction: notification.requireInteraction || false,
          vibrate: [200, 100, 200],
          timestamp: Date.now(),
          silent: notification.silent || false,
        }
      )
    );
  }
  
  // Handle skip waiting message
  if (event.data && event.data.type === 'SKIP_WAITING') {
    self.skipWaiting();
  }
});

// Handle notification clicks
// Task 3.5.4: Comprehensive action handling for notifications
self.addEventListener('notificationclick', (event) => {
  event.notification.close();

  const notificationData = event.notification.data || {};
  const action = event.action;
  const notificationType = notificationData.type || 'system';
  
  // Determine URL based on action and notification type
  let urlToOpen = notificationData.url || '/';
  
  // Handle specific actions
  if (action) {
    console.log('Notification action clicked:', action, 'Type:', notificationType);
    
    switch (action) {
      case 'view':
        // Use the URL from notification data or default
        urlToOpen = notificationData.url || getDefaultUrlForType(notificationType);
        break;
      
      case 'apply':
        // Navigate to job application page
        urlToOpen = notificationData.jobUrl || `/jobs/${notificationData.jobId}/apply`;
        break;
      
      case 'message':
      case 'reply':
        // Navigate to chat/messaging page
        urlToOpen = notificationData.chatUrl || `/chat/${notificationData.conversationId || notificationData.userId}`;
        break;
      
      case 'review':
        // Navigate to application review page
        urlToOpen = notificationData.applicationUrl || `/applications/${notificationData.applicationId}`;
        break;
      
      case 'enroll':
        // Navigate to course enrollment page
        urlToOpen = notificationData.courseUrl || `/courses/${notificationData.courseId}/enroll`;
        break;
      
      case 'later':
        // Mark notification for later review (don't open window)
        event.waitUntil(
          markNotificationForLater(notificationData)
        );
        return; // Don't open window
      
      case 'dismiss':
        // Just close notification (already closed above)
        return; // Don't open window
      
      default:
        console.log('Unknown action:', action);
        urlToOpen = notificationData.url || '/';
    }
  } else {
    // No action clicked, use default URL for notification type
    urlToOpen = notificationData.url || getDefaultUrlForType(notificationType);
  }

  // Open or focus window
  event.waitUntil(
    clients.matchAll({ type: 'window', includeUncontrolled: true })
      .then((clientList) => {
        // Check if there's already a window open with the target URL
        for (const client of clientList) {
          if (client.url === urlToOpen && 'focus' in client) {
            return client.focus();
          }
        }
        
        // Check if there's any window open that we can navigate
        if (clientList.length > 0) {
          const client = clientList[0];
          if ('navigate' in client) {
            return client.navigate(urlToOpen).then(client => client.focus());
          }
        }
        
        // Open new window if none exists
        if (clients.openWindow) {
          return clients.openWindow(urlToOpen);
        }
      })
  );
});

// Helper function to get default URL based on notification type
function getDefaultUrlForType(type) {
  switch (type) {
    case 'job_match':
      return '/jobs';
    case 'application_accepted':
    case 'application_rejected':
    case 'application_reviewed':
      return '/applications';
    case 'new_application':
      return '/admin/applications';
    case 'job_closed':
      return '/jobs';
    case 'course_match':
      return '/courses';
    case 'new_message':
      return '/chat';
    case 'system':
    default:
      return '/notifications';
  }
}

// Helper function to mark notification for later review
async function markNotificationForLater(notificationData) {
  try {
    // Store in IndexedDB or send to backend
    const cache = await caches.open('notification-queue');
    const request = new Request('/api/notifications/mark-later', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(notificationData),
    });
    
    // Try to send to backend
    try {
      const response = await fetch(request);
      if (response.ok) {
        console.log('Notification marked for later review');
      }
    } catch (error) {
      // If offline, cache the request for later sync
      await cache.put(request, new Response(JSON.stringify({ queued: true })));
      console.log('Notification queued for later sync');
    }
  } catch (error) {
    console.error('Failed to mark notification for later:', error);
  }
}

// Background sync for offline requests (FR-PWA-9)
self.addEventListener('sync', (event) => {
  if (event.tag === 'sync-requests') {
    event.waitUntil(syncRequests());
  }
});

async function syncRequests() {
  const cache = await caches.open('failed-requests');
  const requests = await cache.keys();
  
  return Promise.all(
    requests.map(async (request) => {
      try {
        const response = await fetch(request);
        if (response.ok) {
          await cache.delete(request);
        }
        return response;
      } catch (error) {
        console.error('Failed to sync request:', error);
        return null;
      }
    })
  );
}
